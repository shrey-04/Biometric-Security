#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
generate statistics for plotting from comparison,
also calculates eer and threshold.

Source: https://wavelab.at/sources/USIT
Authors: Heinz Hofbauer
"""


import sys
import os.path
import re
import scipy
import scipy.stats
import math
import numpy


def itover(ititem):
    """ iterate over the items in a alist of nested objects"""
    if type(ititem) in [type([]), type(())]:
        for lsub in ititem:
            for result in itover(lsub):
                yield result
    else:
        yield ititem


def usage():
    """ Give usage information """
    print("""
{:s} [options]
   -i    <input filename>    filename with comparisons as generated by koc etc.
   -o    <output filename>   File to write  EER and threshold information to.
   -id   <regex>             regular expression used to get the user id from the
                             filename for genuine/imposter separation.
   -squash <regex>           A filename is expected to be an identifier of the image, if
                             two datasets are compared where the filenames are not equal,
                             use this to squash to filenames to an unique id.
   -b    <bins>              Number of bins for the statistics (default = 1000)
   -d    <stats filename>    File to write genuine and imposter statistics to
   -r    <min:max>           Range of the threshold for normalization (default: 0:1)
    --ignore-case            ignore case in id and line
   Line models:
   --space                   orig, comp and score are separated by spaces
   --function                function(orig,comp)=result <- lines like this
   --regex <regex>           gives regex function to parse the line, return three groups
                             file1, file2 and score. This is a line MATCHER, so the full
                             line must match the regex.
   --odauto                  Sets output (as per -o) and enables stats writing (-d).
                             The output filenames are generated by replacing the extension
                             with `.eer`(-o) and `.stats` (-d). If one of those is the
                             same as the original then instead of replacing the extension
                             it is added.
                             If -o or -d is explixitly given this overrides tht auto mode.

   score modes:
   --reverse                 reverse the score, use if low score is imposter

   Statistics options:
   --R1                      Calculate Rank 1 accuracy (and 5 and 10) for identification.
   --nostatistics            do not perform statistical tests (to save time)
   -c    <compare filename>  compare this input file to the -i file and print statistics

   Note that a sorted file based on the first comparison filename is expected!
    """.format(sys.argv[0]))
    sys.exit(0)

warnings={}
def warnonce(msg):
    global warnings
    if msg in warnings:
        warnings[msg]+=1
        return False
    warnings[msg] = 1
    print(msg)
    return True

def warnlog():
    for msg in warnings:
        print("Warnings:")
        print("{: 8d} {}".format(warnings[msg],msg))


def normalize(config, what_num, reverse=False):
    """ normale score to [0,1] from interval config['range'] """
    what = float(what_num)
    lower, upper = config['range']
    span = float(upper) - float(lower)
    if what is None:
        print("{} {} {}".format(lower, upper, what))
        return "None"
    if reverse:
        if config['reverse']:
            what = 1. - float(what)
        ret = float(lower) + float(what) * span
        if ret < lower:
            ret = lower
        elif ret > upper:
            ret = upper
    else:
        if what < lower or what > upper:
            if warnonce("WARNING: Normalization found a score outside of the normalization range"):
                print("         {}< !{}! >{}".format(lower, what, upper)) 
        ret = (float(what) - float(lower)) / float(span)
        if ret < 0.:
            ret = 0.
        elif ret > 1.:
            ret = 1.
        if config['reverse']:
            ret = 1. - ret
    return ret


def genstatistics(config):
    """ generate statistics for genuine and imposter scores """
    bins = config['bins']
    center_offset = 1. / bins / 2.
    gen_count = 0
    imp_count = 0
    statistics = []
    score_statistics = {'gen': [], 'imp': [], 'id': []}
    fpfn = {}
    for i in range(0, bins):
        statistics.append([normalize(config, float(i) / bins + center_offset, reverse=True), 0, 0, 0, 0])
    fhandle = open(config['filename'], "r")
    if fhandle is None:
        print("Could not open {:s} for reading".format(config['filename']))
        sys.exit(1)
    if config['linemodel'] == 'space':  # default
        splitline = re.compile(r"""
            \s*              #normal start of line
            (?:[^\s]*/)?([^\s]*)\s*      #first filename
            (?:[^\s]*/)?([^\s]*)\s*      #second filename
            ([^\s]*)                     #actual score
            \s*.*                        #filler for the end, like shit shift information
            """, flags=re.UNICODE | re.VERBOSE)
    elif config['linemodel'] == 'function':
        splitline = re.compile(r"""
            .*\(              #normal start of line
            (?:[^,]*/)?([^,]*),      #first filename
            (?:[^,]*/)?([^,]*)\)      #second filename
            \ =\ (.*)           #actual score
            """, flags=re.UNICODE | re.VERBOSE)
    else:
        splitline = re.compile(config['lineregex'], flags=re.UNICODE | re.VERBOSE)
    squash = re.compile(config['fnamesquash'])
    #donelist = []
    idlist = []
    linecount = 0
    for fline in sorted(fhandle):
        if config['ignorecase']:
            line = fline.upper()
        else:
            line = fline
        linecount += 1
        match = splitline.match(line.strip())
        matches = None
        if match is not None and len(match.groups()) == 3:
            matches = match.groups()
        if matches is not None:
            if matches[0] == '' or matches[1] == '' or matches[2] == '':
                matches = None
        if matches is not None:
            morig, mcomp, score = matches
            morig = "".join(itover(squash.findall(morig)))
            mcomp = "".join(itover(squash.findall(mcomp)))
            if mcomp == '' or morig == '':
                if warnonce("WARNING: squashed names are empty:"):
                    print("         orig(", morig, ") comp(", mcomp, ") -- squashpattern(", squash.pattern, ")")
                    print("         LINE :", line.strip())
            #score = float(score)
            score = normalize(config, score)

            if morig == mcomp and morig not in idlist:  # one side only
                idlist.append(morig)
                score_statistics['id'].append(score)
                continue
            #if morig not in donelist:
            #    donelist.append(morig)
            #if mcomp in donelist:
            #    continue  # done already

            idorig = config['idgen'].findall(morig)
            idcomp = config['idgen'].findall(mcomp)
            if not (idorig is None or idcomp is None):

                idorig = "".join(itover(idorig))
                idcomp = "".join(itover(idcomp))

#                mnamekey = idorig + "/" + idcomp
#                if idcomp < idorig:
#                    mnamekey = idcomp + "/" + idorig
                mnamekey = morig + "/" + mcomp
                if mcomp < morig:
                    mnamekey = mcomp + "/" + morig
                if idcomp == "" or idorig == "":
                    if warnonce("WARNING: id empty:"):
                        print("        orig(", idorig, ") comp(", idcomp, ")")
                        print("        PATTERN:", str(config['idgen'].pattern))
                        print("        LINE :", line.strip())
                        print("        MATCH:", match.groups())
                col = None
                if mnamekey in fpfn:
                    continue
                if idorig == idcomp:
                    score_statistics['gen'].append(score)
                    gen_count += 1
                    col = 1
                    fpfn[mnamekey] = (score, 'gen')
                else:
                    score_statistics['imp'].append(score)
                    fpfn[mnamekey] = (score, 'imp')
                    imp_count += 1
                    col = 2
                sbin = int(score * bins)
                #print score, int(score*bins), sbin, " *** "if sbin == 0 else ""

                if sbin == bins:
                    sbin -= 1
                statistics[sbin][col] += 1
            else:
                print("ID could not deduced for {:s} or {:s}".format(idorig, idcomp))
        else:
            if not line.strip() == "":  # empy lines are skipped silently
                print("NO MACTH ON line", linecount)
                print("            LINE:", line.strip())
                print("            WITH:", splitline.pattern)
    for bidx in range(len(statistics)):
        if gen_count > 0:
            statistics[bidx][3] = statistics[bidx][1] / float(gen_count)
            if statistics[bidx][3] >= 1.00:
                print("WTFBBQgen: {}/{} = {}".format(statistics[bidx][1], float(gen_count), statistics[bidx][3]))
        if imp_count > 0:
            statistics[bidx][4] = statistics[bidx][2] / float(imp_count)
            if statistics[bidx][4] >= 1.00:
                print("WTFBBQimp: {}/{} = {}".format(statistics[bidx][2], float(imp_count), statistics[bidx][4]))
    config['gencount'] = gen_count
    config['impcount'] = imp_count
    return statistics, score_statistics, fpfn


def writedist(config, stat):
    """ write statistics information to a file"""
    if config['distfile'] is None:
        return
    outfile = open(config['distfile'], "w")
    if outfile is None:
        print("Could not open {:s} for writing statistics information".format(config['distfile']))
    #labels stuff
    outfile.write("#bincenter gencount impcount genrel imprel FMR FNMR\n")
    #fakey last line to not offset gnuplot fill when last bin is > 0
    outfile.write("{} {} {} {:f} {:f} {:f} {:f}\n".format(normalize(config, 0., reverse=True), 0, 0, 0., 0., 0., 100.))

    falseaccepts = 0
    falserejects = config['gencount']
    for b in stat:
        bc, gc, ic, gr, ir = b
        falseaccepts += ic
        falserejects -= gc
        fmr = float(falseaccepts) / max(1, config['impcount'])
        fnmr = float(falserejects) / max(1, config['gencount'])
        fmr *= 100  # convert to %
        fnmr *= 100  # convert to %
        gr *= 100  # convert relatives to percent
        ir *= 100  # convert relatives to percent
        outfile.write("{} {} {} {:f} {:f} {:f} {:f}\n".format(bc, gc, ic, gr, ir, fmr, fnmr))
    #fakey last line to not offset gnuplot fill when last bin is > 0
    outfile.write("{} {} {} {:f} {:f} {:f} {:f}\n".format(normalize(config, 1., reverse=True), 0, 0, 0., 0., 100., 0.))
    outfile.close()


def showconfig(config):
    output = sys.stdout
    if not config['outfile'] is None:
        output = open(config['outfile'], "a+")
        if output is None:
            print("Could not open {:s} for writing output informataion, reverting to stdout".format(config['outfilel']))
            output = sys.stdout
    for k, v in config.items():
        if hasattr(v, "pattern"):
            v = getattr(v, "pattern")
        output.write("CONFIG   {}:={}\n".format(k, v))


class Prefixer:
    def __init__(self, prefix):
        self.prefix = str(prefix)

    def write(self, instring, *args, **kwargs):
        sys.stdout.write(self.prefix + str(instring), *args, **kwargs)


def calculateEER(config, stat):
    """ Calculate the statistics, if an outfile is defined the
        output is written to the file instead of stdout """
    failearly = False
    if config['impcount'] == 0:
        print("EE: Imposter count is zero (0)")
        failearly = True
    if config['gencount'] == 0:
        print("EE: Genuine count is zero (0)")
        failearly = True
    if failearly:
        print("II: Cannot calculate EER, threshold etc. breaking")
        return -1
    falseaccepts = 0
    falserejects = config['gencount']
    lastfalseaccepts = falseaccepts
    lastfalserejects = falserejects
    EER = None
    TFMR = 0.001
    FNMR = None
    TFMRh = 0.0001
    FNMRh = None
    TFMRz = 0.0
    FNMRz = None
    TFNMR = 0.001
    FMR = None
    TFNMRh = 0.0001
    FMRh = None
    TFNMRz = 0.0
    FMRz = None
    threshold = None
    OVL = 0
    #Overlapping coefficient  based on bining as given, see http://www.tandfonline.com/doi/abs/10.1080/03610928908830127
    AUC = 0
    AUC_TPR = 0
    AUC_FPR = 0
    AUC_last = [0, 0]
    for i in range(0, config['bins']):
        OVL += min(stat[i][3], stat[i][4])
        AUC_TPR += stat[i][3]
        AUC_FPR += stat[i][4]
        AUC_w = AUC_FPR - AUC_last[0]
        AUC_dh = AUC_TPR - AUC_last[1]
        AUC += AUC_w * AUC_last[1] + (AUC_w * AUC_dh) / 2
        AUC_last = [AUC_FPR, AUC_TPR]
        falseaccepts += stat[i][2]
        falserejects -= stat[i][1]
        if lastfalseaccepts != falseaccepts or lastfalserejects != falserejects:
            fmr = float(falseaccepts) / max(1, config['impcount'])
            fnmr = float(falserejects) / max(1, config['gencount'])

            lastfmr = float(lastfalseaccepts) / max(1, config['impcount'])
            lastfnmr = float(lastfalserejects) / max(1, config['gencount'])
            if EER is None:
                if fmr == fnmr:
                    EER = fmr
                    threshold = (i + 1.) / config['bins']
                    #break
                elif fmr > fnmr:  # interpolate
                    #lastfmr = float(lastfalseaccepts) / config['impcount']
                    #lastfnmr = float(lastfalserejects) / config['gencount']
                    EER = (-lastfmr * fnmr + lastfnmr * fmr) / (lastfnmr - lastfmr - fnmr + fmr)
                    threshold = (i + 1.) / config['bins']  # should also be interpolated
                    #break
            if FNMR is None or fmr == TFMR:
                if fmr == TFMR:
                    FNMR = fnmr
                elif fmr > TFMR:
                    fmrdist = (fmr - TFMR) / (fmr - lastfmr)
                    FNMR = fnmr + fmrdist * (lastfnmr - fnmr)
            if FNMRh is None or fmr == TFMRh:
                if fmr == TFMRh:
                    FNMRh = fnmr
                elif fmr > TFMRh:
                    fmrdist = (fmr - TFMRh) / (fmr - lastfmr)
                    FNMRh = fnmr + fmrdist * (lastfnmr - fnmr)
            if FNMRz is None or fmr == TFMRz:
                if fmr == TFMRz:
                    FNMRz = fnmr
                elif fmr > TFMRz:
                    fmrdist = (fmr - TFMRz) / (fmr - lastfmr)
                    FNMRz = fnmr + fmrdist * (lastfnmr - fnmr)
            if FMR is None:
                if fnmr == TFNMR:
                    FMR = fmr
                elif fnmr < TFNMR:
                    fnmrdist = (lastfnmr - TFNMR) / (lastfnmr - fnmr)
                    FMR = lastfmr + fnmrdist * (fmr - lastfmr)
            if FMRh is None:
                if fnmr == TFNMRh:
                    FMRh = fmr
                elif fnmr < TFNMRh:
                    fnmrdist = (lastfnmr - TFNMRh) / (lastfnmr - fnmr)
                    FMRh = lastfmr + fnmrdist * (fmr - lastfmr)
            if FMRz is None:
                if fnmr == TFNMRz:
                    FMRz = fmr
                elif fnmr < TFNMRz:
                    fnmrdist = (lastfnmr - TFNMRz) / (lastfnmr - fnmr)
                    FMRz = lastfmr + fnmrdist * (fmr - lastfmr)
            lastfalserejects = falserejects
            lastfalseaccepts = falseaccepts
    output = sys.stdout
    output = Prefixer(config['prefix'])
    if not config['outfile'] is None:
        output = open(config['outfile'], "a+")
        if output is None:
            print("Could not open {:s} for writing output informataion, reverting to stdout".format(config['outfilel']))
            output = sys.stdout
            output = Prefixer(config['prefix'])
    output.write("%d genuines, %d imposters\n" % (config['gencount'], config['impcount']))
    output.write("EER = {:%} at threshold t = {} \n".format(EER, normalize(config, threshold, reverse=True)))
    output.write("OVL_b = {:%}\n".format(OVL))
    output.write("AUC_b = {:%}\n".format(AUC))
    output.write("FNMR = {:%} at FMR = {:%} \n".format(FNMR, TFMR))
    output.write("FNMR = {:%} at FMR = {:%} \n".format(FNMRh, TFMRh))
    output.write("FNMR = {:%} at FMR = {:%} \n".format(FNMRz, TFMRz))
    output.write("FMR = {:%} at FNMR = {:%} \n".format(FMR, TFNMR))
    output.write("FMR = {:%} at FNMR = {:%} \n".format(FMRh, TFNMRh))
    output.write("FMR = {:%} at FNMR = {:%} \n".format(FMRz, TFNMRz))
    return threshold


def calculateRoneACC(config, fpfn):
    bygallery = {}
    maximpnumber = 0
    for k in fpfn.keys():
        a, b = k.split("/")
        if a not in bygallery:
            bygallery[a] = [[], []]
        if b not in bygallery:
            bygallery[b] = [[], []]
        if fpfn[k][1] == 'gen':
            bygallery[a][0].append(fpfn[k][0])
            bygallery[b][0].append(fpfn[k][0])
        else:
            bygallery[a][1].append(fpfn[k][0])
            bygallery[b][1].append(fpfn[k][0])
        maximpnumber = max(maximpnumber, len(bygallery[a][1]), len(bygallery[b][1]))
    #correct = 0.
    allgenscores = []
    allimpscores = []
    genbeforeimp = []
    for k in bygallery.keys():
        mimp = min(bygallery[k][1])
        for g in bygallery[k][0]:
            if g < mimp:
                genbeforeimp.append(g)
        allgenscores.extend(bygallery[k][0])
        allimpscores.extend(bygallery[k][1])
    total_oneisgallery = 0.
    ranks_oneisgallery = [0 for i in range(maximpnumber)]
    total_oneisquery = 0.
    ranks_oneisquery = [0 for i in range(maximpnumber)]
    result_votes = [0 for i in range(maximpnumber)]
    for image in bygallery.keys():
        implist = sorted(bygallery[image][1])
        genlist = sorted(bygallery[image][0])
        #impbest = implist[0]  # min(bygallery[image][1])
        for picscore in bygallery[image][0]:
            total_oneisgallery += 1
            #if picscore < impbest:
            #    correct += 1
            for rid in range(len(ranks_oneisgallery)):
                ranks_oneisgallery[rid] += 1 if rid < len(implist) and picscore < implist[rid] else 0
        if len(bygallery[image][0]) == 0:
            continue
        total_oneisquery += 1
        #picscore = min(bygallery[image][0])
        picscore = genlist[0]
        for rid in range(len(ranks_oneisquery)):
            ranks_oneisquery[rid] += 1 if rid < len(implist) and picscore < implist[rid] else 0
        #vote
        #this is wrong and groups all imposter together as one user.
#        gidx = 0
#        iidx = 0
#        maxvotes = 2 * len(genlist)
#        votes = [0 for i in range(maxvotes)]
#        countvotes = 0
#        while countvotes < maxvotes:
#            if gidx < len(genlist) and iidx < len(implist) and genlist[gidx] < implist[iidx]:
#                gidx += 1
#                for v in range(countvotes, maxvotes):
#                    votes[v] += 1
#            else:
#                iidx += 1
#            countvotes += 1
#        for idx in range(maxvotes):
#            if votes[idx] / (1. + idx) > 0.5:
#                result_votes[idx] += 1
#
    ranks_oneisgallery = [r / total_oneisgallery for r in ranks_oneisgallery]
    ranks_oneisquery = [r / total_oneisquery for r in ranks_oneisquery]
    result_votes = [v / total_oneisquery for v in result_votes]

    output = sys.stdout
    output = Prefixer(config['prefix'])
    if not config['outfile'] is None:
        output = open(config['outfile'], "a+")
        if output is None:
            print("Could not open {:s} for writing output informataion, reverting to stdout".format(config['outfilel']))
            output = sys.stdout
            output = Prefixer(config['prefix'])
    output.write("OIG Mode: One genuine is in gallery, all imposter are in gallery. The rest of the genuines is individually used as a query.\n")
    output.write("    OIG Identification (Rank 1) Accuracy = {:%}\n".format(ranks_oneisgallery[1 - 1]))
    output.write("    OIG Rank  5 Accuracy = {:%}\n".format(ranks_oneisgallery[5 - 1]))
    output.write("    OIG Rank 10 Accuracy = {:%}\n".format(ranks_oneisgallery[10 - 1]))
    output.write("OIQ Mode: One genuine is the query, all other geuines and all imposters form the gallery.\n")
    output.write("    OIQ Identification (Rank 1) Accuracy = {:%}\n".format(ranks_oneisquery[1 - 1]))
    output.write("    OIQ Rank  5 Accuracy = {:%}\n".format(ranks_oneisquery[5 - 1]))
    output.write("    OIQ Rank 10 Accuracy = {:%}\n".format(ranks_oneisquery[10 - 1]))
#    output.write("MJV Mode: OIG setup, take the first N returns and use majority voting (equal vote rejects).\n")
#    output.write("    MJV Identification (Rank 1) Accuracy = {:%}\n".format(result_votes[1 - 1]))
#    output.write("    MJV Rank 3 Accuracy = {:%}\n".format(result_votes[3 - 1]))
#    output.write("    MJV Rank 5 Accuracy = {:%}\n".format(result_votes[5 - 1]))
    output.write("Score Distributions:\n")
    output.write("    GEN µ={:.3f} σ={:.3f} ∈[{:.3f}, {:.3f}]\n".format(
        normalize(config, numpy.average(allgenscores), reverse=True),
        normalize(config, numpy.std(allgenscores), reverse=True),
        normalize(config, numpy.min(allgenscores), reverse=True),
        normalize(config, numpy.max(allgenscores), reverse=True),
    ))
    output.write("    IMP µ={:.3f} σ={:.3f} ∈[{:.3f}, {:.3f}]\n".format(
        normalize(config, numpy.average(allimpscores), reverse=True),
        normalize(config, numpy.std(allimpscores), reverse=True),
        normalize(config, numpy.min(allimpscores), reverse=True),
        normalize(config, numpy.max(allimpscores), reverse=True),
    ))
    if len(genbeforeimp) > 0:
        output.write("    GEN<IMP per user and combined\n")
        output.write("    GEN<IMP µ={:.3f} σ={:.3f} ∈[{:.3f}, {:.3f}]\n".format(
            normalize(config, numpy.average(genbeforeimp), reverse=True),
            normalize(config, numpy.std(genbeforeimp), reverse=True),
            normalize(config, numpy.min(genbeforeimp), reverse=True),
            normalize(config, numpy.max(genbeforeimp), reverse=True),
        ))
    else:
        output.write("    GEN<IMP Never happens!\n")

    #return correct / total


def comparestatistics(stat1, stat2, config):
    output = sys.stdout
    output = Prefixer(config['prefix'])
    if not config['outfile'] is None:
        output = open(config['outfile'], "a+")
        if output is None:
            print("Could not open {:s} for writing output informataion, reverting to stdout".format(config['outfilel']))
            output = sys.stdout
            output = Prefixer(config['prefix'])
    output.write("Kolmogorov Smirnov 2-sample statistics test\n")
    output.write("H₀: The samples are drawn from the same underlying (unknown) distribution.\n")
    for k in 'id', 'gen', 'imp':
        KS_stat, KS_pval = scipy.stats.ks_2samp(stat1[k], stat2[k])
        output.write("  {}: {} KS_statistic({}) p-value({})\n".format(k, "-REJECT" if KS_pval < 0.05 else "?SAME", KS_stat, KS_pval))


def mcnemar(threshold, fpfn, threshold2, fpfn2, config):
    cd = set()  # before wrong
    bd = set()  # after wrong
    for k in fpfn.keys():
        cor = "gen" if fpfn[k][0] <= threshold else "imp"
        if not cor == fpfn[k][1]:
            cd.add(k)
        cor = "gen" if fpfn2[k][0] <= threshold2 else "imp"
        if not cor == fpfn2[k][1]:
            bd.add(k)

    d = len(bd.intersection(cd))  # get intersection size
    c = len(cd) - d  # card (c + d) - card(d) = card( c )
    b = len(bd) - d  # card (b + d) - card(d) = card( b )

    N = config['gencount'] + config['impcount']
    a = N - c - b - d
    #using approx by chi² insteas of binomial, edwards correction is used
    X2 = math.pow(abs(b - c) - 1, 2) / float(b + c)
    pval = 1. - scipy.stats.chi2.cdf(X2, df=1)

    output = sys.stdout
    output = Prefixer(config['prefix'])
    if not config['outfile'] is None:
        output = open(config['outfile'], "a+")
        if output is None:
            print("Could not open {:s} for writing output informataion, reverting to stdout".format(config['outfilel']))
            output = sys.stdout
            output = Prefixer(config['prefix'])
    output.write("McNemar: correctly classified (RIGHT) vs. incorrectly classified (WRONG)\n")
    output.write("H₀: Distribution between B and C are random occurrences based on binomial distribution with p=q=0.5 .\n")
    output.write("Approximation by Chi² and Edward's correction is used.\n")
    output.write("N={}, A={}, B={}, C={}, D={}\n".format(N, a, b, c, d))
    output.write("         AFTER²             \n")
    output.write(" B  +-RIGHT-+-WRONG-+-------\n")
    output.write(" E  R   A   | {:4d} |       \n".format(b))
    output.write(" F  +-------+-------+-------\n")
    output.write(" O  W {:4d} |   D   |       \n".format(c))
    output.write(" R  +-------+-------+-------\n")
    output.write(" E¹ |       |       | {}    \n".format(N))
    output.write("    Before¹: {}\n".format(config['comparefile']))
    output.write("    After²:  {}\n".format(config['filename']))
    output.write("{} -- X²={} -- pval={}\n".format("-REJECT({} is better)".format("After²" if c > b else "Before¹") if pval < 0.05 else "?SAME", X2, pval))


def main(argv):
    """ check argvector and start statistic generation or give usage prompt """

    config = {
        'filename': None,
        'comparefile': None,
        'idgen': None,
        'fnamesquash': '(.*)',
        'bins': 1000,
        'outfile': None,
        'distfile': None,
        'range': [0, 1],
        'linemodel': 'space',
        'reverse': False,
        'statistics': True,
        'ignorecase': False,
        'rankaccuracy': False,
    }
    odauto = False
    argc = len(argv)
    idx = 0
    while idx < argc:
        if argv[idx] == "-i":
            idx += 1
            if idx < argc:
                config['filename'] = argv[idx]
        elif argv[idx] == "-c":
            idx += 1
            if idx < argc:
                config['comparefile'] = argv[idx]
        elif argv[idx] == "-id":
            idx += 1
            if idx < argc:
                config['idgen'] = argv[idx]
        elif argv[idx] == "-squash":
            idx += 1
            if idx < argc:
                config['fnamesquash'] = argv[idx]
        elif argv[idx] == "-b":
            idx += 1
            if idx < argc:
                config['bins'] = int(argv[idx])
        elif argv[idx] == "-d":
            idx += 1
            if idx < argc:
                config['distfile'] = argv[idx]
        elif argv[idx] == "-o":
            idx += 1
            if idx < argc:
                config['outfile'] = argv[idx]
        elif argv[idx] == "-r":
            idx += 1
            if idx < argc:
                config['range'] = [float(mm) for mm in argv[idx].split(":")]
        elif argv[idx] == "--ignore-case":
            config['ignorecase'] = True
        elif argv[idx] == "--space":
            config['linemodel'] = 'space'
        elif argv[idx] == "--function":
            config['linemodel'] = 'function'
        elif argv[idx] == "--regex":
            config['linemodel'] = 'regex'
            config['lineregex'] = ""
            idx += 1
            if idx < argc:
                config['lineregex'] = argv[idx]
        elif argv[idx] == "--reverse":
            config['reverse'] = True
        elif argv[idx] == "--nostatistics":
            config['statistics'] = False
        elif argv[idx] == "--R1":
            config['rankaccuracy'] = True
        elif argv[idx] == "--odauto":
            odauto = True
        else:
            print(("unsupported option", argv[idx]))
            usage()
        idx += 1

    if config['filename'] is None or config['idgen'] is None:
        print("One or more required inputs are missing:")
        print("  input  (-i): {}\n  idgen (-id): {}".format(config['filename'], config['idgen']))
        usage()
    if odauto:
        base, ext = os.path.splitext(config['filename'])
        if ext in [".eer", ".stats"]:
            base += ext
        if config['outfile'] is None:
            config['outfile'] = base + ".eer"
            print("Config odauto (-o): {outfile}".format(**config))
        if config['distfile'] is None:
            config['distfile'] = base + ".stats"
            print("Config odauto (-d): {distfile}".format(**config))
    config['idgen'] = re.compile(config['idgen'])
    statistics, score_statistics, fpfn = genstatistics(config)
    showconfig(config)
    print(config)
    if config['comparefile'] is not None:
        print("FILE:", config['filename'])
        config['prefix'] = "    | "
    else:
        config['prefix'] = ""
    writedist(config, statistics)
    #showstatistics(config, score_statistics)
    threshold = calculateEER(config, statistics)
    if config['rankaccuracy']:
        calculateRoneACC(config, fpfn)

    if config['comparefile'] is not None:
        config['filename'], config['comparefile'] = config['comparefile'], config['filename']
        statistics2, score_statistics2, fpfn2 = genstatistics(config)

        print("FILE:", config['filename'])
        config['prefix'] = "    | "

        #showstatistics(config, score_statistics2)
        threshold2 = calculateEER(config, statistics2)

        comparestatistics(score_statistics, score_statistics2, config)
        mcnemar(threshold, fpfn, threshold2, fpfn2, config)

    #print statistics


if __name__ == '__main__':
    main(sys.argv[1:])
    warnlog()
